### src and dst = 0x01, 0x02, 0x10 ###

Pre-invariant : [
    meta_offset=[-4098, 0], 
    packet_size=[0, 65534], 
    r1.ctx_offset=0, r1.type=ctx, r1.value=[1, 2147418112], 
    r10.stack_offset=512, r10.type=stack, r10.value=[512, 2147418112]]
Stack: Numbers -> {}
entry:
  r0 = 0;
  assert r0.type in {ctx, stack, packet, shared};
  assert valid_access(r0.offset-8, width=8) for write;
  assert r0.type != stack -> r1.type == number;
  *(u64 *)(r0 - 8) = r1;
  r2 = r0;
  assert r2.type in {number, ctx, stack, packet, shared};
  r2 += -8;
  r1 = 1;
  assert r1.type == map_fd;
  assert r2.type in {stack, packet};
  assert within stack(r2:key_size(r1));
  r0 = map_lookup_elem:1(map_fd r1, map_key r2);
  assert r0.type == number;
  assert r0.type == number;
  exit;
  goto exit;

Post-invariant: [
    meta_offset=[-4098, 0], 
    packet_size=[0, 65534], 
    r0.shared_offset=0, r0.type=shared, r0.value=[0, 2147418112], 
    r10.stack_offset=512, r10.type=stack, r10.value=[512, 2147418112]]
Stack: Numbers -> {}

Pre-invariant : _|_
8:
  assert r0.type in {ctx, stack, packet, shared};
  assert valid_access(r0.offset, width=8) for read;
  r1 = *(u64 *)(r0 + 0);
  assert r0.type in {ctx, stack, packet, shared};
  assert valid_access(r0.offset+8, width=8) for read;
  r2 = *(u64 *)(r0 + 8);
  assert r0.type == number;
  exit;
  goto exit;

Post-invariant: _|_

Pre-invariant : [
    meta_offset=[-4098, 0], 
    packet_size=[0, 65534], 
    r0.shared_offset=0, r0.type=shared, r0.value=[0, 2147418112], 
    r10.stack_offset=512, r10.type=stack, r10.value=[512, 2147418112]]
Stack: Numbers -> {}
exit:


Post-invariant: [
    meta_offset=[-4098, 0], 
    packet_size=[0, 65534], 
    r0.shared_offset=0, r0.type=shared, r0.value=[0, 2147418112], 
    r10.stack_offset=512, r10.type=stack, r10.value=[512, 2147418112]]
Stack: Numbers -> {}

entry:  (r0.type in {ctx, stack, packet, shared})
entry: Only pointers can be dereferenced (valid_access(r0.offset-8, width=8) for write)
entry: Only numbers can be stored to externally-visible regions (r0.type != stack -> r1.type == number)
entry:  (r1.type == map_fd)
entry:  (r2.type in {stack, packet})
entry: Map key size is not singleton (within stack(r2:key_size(r1)))
entry:  (r0.type == number)
entry:  (r0.type == number)


### data.o 0x ###

00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..>.............|
00000020  00 00 00 00 00 00 00 00  20 01 00 00 00 00 00 00  |........ .......|
00000030  00 00 00 00 40 00 38 00  00 00 40 00 05 00 01 00  |....@.8...@.....|
00000040  b7 00 00 00 00 00 00 00  7b 10* f8 ff 00 00 00 00  |........{.......|
00000050  bf 0*2 00 00 00 00 00 00  07 02 00 00 f8 ff ff ff  |................|
00000060  b7 01 00 00 01 00 00 00  85 10 00 00 01 00 00 00  |................|
00000070  55 00 00 00 01 00 00 00  95 00 00 00 00 00 00 00  |U...............|
00000080  79 01 00 00 00 00 00 00  79 02 08 00 00 00 00 00  |y.......y.......|
00000090  95 00 00 00 00 00 00 00  00 2e 73 74 72 74 61 62  |..........strtab|
000000a0  00 2e 73 79 6d 74 61 62  00 2e 2e 2f 6f 62 6a 2d  |..symtab.../obj-|
000000b0  66 69 6c 65 73 2f 64 61  74 61 2e 6f 00 2e 74 65  |files/data.o..te|
000000c0  78 74 00 2e 6e 6f 74 65  2e 47 4e 55 2d 73 74 61  |xt..note.GNU-sta|
000000d0  63 6b 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |ck..............|
000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000f0  11 00 00 00 04 00 f1 ff  00 00 00 00 00 00 00 00  |................|
00000100  00 00 00 00 00 00 00 00  00 00 00 00 03 00 03 00  |................|
00000110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000160  01 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
00000170  00 00 00 00 00 00 00 00  98 00 00 00 00 00 00 00  |................|
00000180  3b 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |;...............|
00000190  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000001a0  09 00 00 00 02 00 00 00  00 00 00 00 00 00 00 00  |................|
000001b0  00 00 00 00 00 00 00 00  d8 00 00 00 00 00 00 00  |................|
000001c0  48 00 00 00 00 00 00 00  01 00 00 00 03 00 00 00  |H...............|
000001d0  08 00 00 00 00 00 00 00  18 00 00 00 00 00 00 00  |................|
000001e0  25 00 00 00 01 00 00 00  00 00 00 00 00 00 00 00  |%...............|
000001f0  00 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000200  58 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |X...............|
00000210  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000220  2b 00 00 00 01 00 00 00  00 00 00 00 00 00 00 00  |+...............|
00000230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000250  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000260
